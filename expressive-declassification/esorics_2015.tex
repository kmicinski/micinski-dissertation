\documentclass{llncs}
\usepackage{url}
\usepackage{latexsym,amsmath,amssymb,stmaryrd}

\pagestyle{headings} % Page numbers for draft

%\renewcommand{\bfdefault}{b}

\usepackage{xspace}
\usepackage{enumitem}
%\usepackage{enumerate}
\usepackage[caption=false]{subfig}
%\usepackage{subcaption}
%\usepackage{subfigure}
\usepackage{listings}
%\usepackage{supertabular}
%\usepackage{stackrel}
%\usepackage{marvosym}
\usepackage{pgf}
%\usepackage{tikz}
%\usepackage{mdframed}
\usepackage{mathpartir}
%\usepackage{etoolbox}
\usepackage{color}
\usepackage{soul}
\usepackage{subscript}
%\usepackage{float}
\usepackage[normalem]{ulem}  % for \sout

% Listings
\newcommand{\code}[1]{\textsf{#1}} %{\text{\lstinline!#1!}}
\newcommand{\bcode}[1]{\texttt{#1}}

\definecolor{lightgreen}{rgb}{.85,.95,.85}
\definecolor{lightblue}{rgb}{.85,.90,1}
\definecolor{lightred}{rgb}{.95,.85,.85}
\definecolor{lightgrey}{rgb}{.95,.95,.95}
\sethlcolor{lightred}

\definecolor{drkyellow}{rgb}{0.4,0.3,0}
\definecolor{drkred}{rgb}{0.5,0,0}
\definecolor{drkgreen}{rgb}{0,0.5,0}

\definecolor{dkgreen}{rgb}{0.1,0.40,0.1}

\definecolor{dkred}{rgb}{0.5,0,0}
\definecolor{medred}{rgb}{0.6,0,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\newcommand{\myparagraph}[1]{\paragraph{#1.}}

\newcommand{\lstrule}{%
 \hspace{1mm}%
 \color{gray}{\rule[1.18mm]{0.8\textwidth}{0.1pt}}%
 \hspace{\fill}%
}

%% TODO: Make the listings look prettier

\lstset{language=Java,
  morecomment=[l]{--},          % add Haskell comment style
  columns=flexible,
  basicstyle=\footnotesize\sffamily,
%  basewidth=0.5em,
%  lineskip={-2.35pt},
%  aboveskip=5mm,
%  belowskip=-5mm,
%  identifierstyle=\textbf,
%  keywordsprefix=\#,
  literate={->}{$\rightarrow$}2
           {=>}{$\Rightarrow$}2
           {<-}{$\leftarrow$}2
           {...}{$\ldots$}2
           {fun}{$\lambda$}1
           {||}{$\parallel$}1
           {**}{$\times$}2,
  escapechar=@,
  escapeinside={/**}{*/},
  numbers=left,                   % where to put the line-numbers
  numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
  stepnumber=1,                   % the step between two line-numbers. If it's 1, each line 
                                  % will be numbered
  numbersep=5pt,                  % how far the line-numbers are from the code
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  numberblanklines=false,
  showtabs=false,
  frame=single,                   % adds a frame around the code
%  frame=lines,
  rulecolor=\color{gray},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
%  tabsize=2,                      % sets default tabsize to 2 spaces
%  captionpos=b,                   % sets the caption-position to bottom
%  breaklines=false,                % sets automatic line breaking
%  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
%  title=\lstname,                   % show the filename of files included with \lstinputlisting;
%  keywordstyle=\color{blue},          % keyword style
%  identifierstyle=\color{drkgreen},     
%  backgroundcolor=\color{lightgrey},
  commentstyle=\color{dkred}\itshape,       % comment style
  stringstyle=\color{mauve}         % string literal style
}

% \lstset{language=Caml,
%   morecomment=[l]{--},          % add Haskell comment style
%   columns=flexible,
%   basicstyle=\small\sffamily,
% %  basewidth=0.5em,
% %  lineskip={-2.35pt},
% %  aboveskip=5mm,
% %  belowskip=-5mm,
% %  identifierstyle=\textbf,
% %  keywordsprefix=\#,
%   literate={->}{$\rightarrow$}2
%            {=>}{$\Rightarrow$}2
%            {<-}{$\leftarrow$}2
%            {..}{$\cdots$}2
%            {fun}{$\lambda$}1
%            {||}{$\parallel$}1
%            {**}{$\times$}2,
%   escapechar=@,
%   escapeinside={/**}{*/},
%   numbers=left,                   % where to put the line-numbers
%   numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
%   stepnumber=1,                   % the step between two line-numbers. If it's 1, each line 
%                                   % will be numbered
%   numbersep=5pt,                  % how far the line-numbers are from the code
%   showspaces=false,               % show spaces adding particular underscores
%   showstringspaces=false,         % underline spaces within strings
%   numberblanklines=false,
%   showtabs=false,
%   frame=single,                   % adds a frame around the code
% %  frame=lines,
%   rulecolor=\color{gray},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
% %  tabsize=2,                      % sets default tabsize to 2 spaces
% %  captionpos=b,                   % sets the caption-position to bottom
% %  breaklines=false,                % sets automatic line breaking
% %  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
% %  title=\lstname,                   % show the filename of files included with \lstinputlisting;
% %  keywordstyle=\color{blue},          % keyword style
% %  identifierstyle=\color{drkgreen},     
% %  backgroundcolor=\color{lightgrey},
%   commentstyle=\color{dkred}\itshape,       % comment style
%   stringstyle=\color{mauve}         % string literal style
% }


%\lstset{emph={},emphstyle={}}%
%\lstset{morekeywords={\!, (, \), \., \<, \>, ref, in, if,then,else,let, install, <,>},keywordstyle={\color{blue}\bfseries}}%



%% Theorem stuff
%\theoremstyle{definition}
%\newtheorem{definition}{Definition}
\newtheorem{algorithm}{Algorithm}

\newcommand{\aset}[1]{\{#1\}}
\newcommand{\dom}{\mathop\textit{dom}\nolimits}

%% Names of things
\newcommand{\tvetl}{TVETL\xspace}

\newcommand{\sfmt}[1]{\textsf{#1}}
\newcommand{\sch}{\textit{name}}
\newcommand{\loc}{\ell}
\newcommand{\sassign}[2]{#1 := #2}
\newcommand{\scase}[2]{\sfmt{case}~#1~\sfmt{of}~#2}
\newcommand{\sderef}[1]{!#1}
\newcommand{\sfalse}{\sfmt{false}}
\newcommand{\sif}[3]{\sfmt{if}~#1~\sfmt{then}~#2~\sfmt{else}~#3}
\newcommand{\bdenot}[1]{\llbracket~#1\rrbracket_B}
\newcommand{\sinl}{\sfmt{inl}}
\newcommand{\sinr}{\sfmt{inr}}
\newcommand{\sinstall}[2]{\sfmt{install}~#1~#2}
\newcommand{\sdeclassify}[1]{\sfmt{declassify}~#1}
\newcommand{\sref}[1]{\sfmt{ref}~#1}
\newcommand{\denot}[1]{\ensuremath{\llbracket #1 \rrbacket}}
\newcommand{\ssend}[2]{\sfmt{send}~#1~#2}
\newcommand{\strue}{\sfmt{true}}
\newcommand{\sunit}{\sfmt{unit}}
\newcommand{\sreduce}{\Downarrow}
\newcommand{\treduce}{\rightarrow}
\newcommand{\partialfun}{\rightharpoonup}
\newcommand{\ltrue}{\ensuremath{\top}}
\newcommand{\lfalse}{\ensuremath{\bot}}
\newcommand{\config}[1]{\langle{}#1\rangle{}}
\newcommand{\program}[1]{\ensuremath{\mathcal{#1}}}
\newcommand{\sclass}[2]{\ensuremath{\lfloor#1\rfloor_{#2}}}
\newcommand{\restr}[2]{\ensuremath{\left.#1\right|_{#2}}}
\newcommand{\modelsrcon}{\models^{r}}
\newcommand{\amodels}{\models^{A}}
\newcommand{\judge}{\vdash}
\newcommand{\xv}{p}
\newcommand{\bexpr}{b}
\newcommand{\filter}{\upharpoonright}
\newcommand{\restrict}{\upharpoonright}
\newcommand{\etlb}{ETLB\xspace}
\newcommand{\hyperltltwo}{HyperLTL\xspace}

\newcommand{\absstate}{\Sigma^s}
\newcommand{\tvar}{x^t}

%\newcommand{\traces}{\textit{traces}}
%\newcommand{\tracesrename}{\textit{traces'}}
\newcommand{\tick}[1]{#1^{+}}
\newcommand{\atom}{A}
\newcommand{\toolname}{ClickRelease\xspace}

\newcommand{\tr}{t\xspace}
\newcommand{\typ}{\tau}
\newcommand{\tint}{\textit{int}}
\newcommand{\tset}{\ensuremath{\mathcal{T}}\xspace}
\newcommand{\tsets}{\ensuremath{\mathcal{T}^s}\xspace}
\newcommand{\pset}{\ensuremath{\mathcal{P}}}
\newcommand{\tnext}{\mathcal{X}}
\newcommand{\talways}{\mathcal{G}}
%\newcommand{\tfuture}{~\mathcal{F}~}
\newcommand{\tevent}{\lozenge}
\newcommand{\tfuture}{\mathcal{F}}
\newcommand{\tuntil}{~\mathcal{U}~}
\newcommand{\tsince}{~\mathcal{S}~}
\newcommand{\tpast}{\mathcal{P}}
\newcommand{\tknows}[1]{\mathcal{K}_{#1}}
\newcommand{\tatmost}[1]{\mathcal{N}_{#1}}
\newcommand{\tpossible}[1]{\mathcal{L}_{#1}}
\newcommand{\tthen}{~\textit{then}~}
\newcommand{\tlast}[2]{\textit{last}(#1, #2)}
\newcommand{\limplies}{\rightarrow}
%\newcommand{\tforall}{\hbox{forall}~}
\newcommand{\texists}{\hbox{exists}~}
\newcommand{\tcurrent}[1]{\hbox{current}_{#1}~}
\newcommand{\tval}[1]{\textit{value}(#1)}
\newcommand{\trelease}{\rhd}
\newcommand{\evt}{\eta}
\newcommand{\mimplies}{\Rightarrow}
\newcommand{\with}{\&}
\newcommand{\tlevel}[3]{\textit{level}(#1, #2, #3)}
\newcommand{\tleveltr}[2]{\textit{level}(#1, #2)}
%\newcommand{\tlevel}[3]{\llbracket #1 \rrbracket_{#2} [#3]}


%% for comments
\newcommand{\comment}[3][\color{red}]{{#1{[{#2}: {#3}]}}}
\newcommand{\kris}[1]{\comment[\color{orange}]{kris}{#1}}
\newcommand{\jeff}[1]{\comment[\color{green}]{JSF}{#1}}
\newcommand{\mrc}[1]{\comment[\color{blue}]{MRC}{#1}}
\newcommand{\jon}[1]{\comment[\color{purple}]{JFD}{#1}}
\newcommand{\jsjeon}[1]{\comment[\color{magenta}]{JJ}{#1}}
\newcommand{\thickhline}{\noalign{\hrule height 1pt}}

\newcommand{\rsout}[1]{{\color{blue}\sout{#1}}}
\newcommand{\review}[1]{{\color{blue}{#1}}}

\begin{document}
\title{Checking Interaction-Based
  Declassification Policies for Android Using Symbolic Execution}

\author{Kristopher Micinski\inst{1} \and
  Jonathan Fetter-Degges\inst{1} \and
  Jinseong Jeon\inst{1} \and \\
  Jeffrey S. Foster\inst{1} \and
  Michael R. Clarkson\inst{2}}
\institute{University of Maryland, College Park \\
\email{\{micinski,jonfd,jsjeon,jfoster\}@cs.umd.edu}
\and 
Cornell University \\
\email{clarkson@cs.cornell.edu}
}

\maketitle

\begin{abstract} 
  Mobile apps can access a wide variety of secure information, such as
  contacts and location. However, current mobile platforms include
  only coarse access control mechanisms to protect such data.  In this
  paper, we introduce \emph{interaction-based declassification
    policies}, in which the user's interactions with the app constrain
  the release of sensitive information.  Our policies are defined
  extensionally, so as to be independent of the app's implementation,
  based on sequences of security-relevant events that occur in app
  runs. Policies use LTL formulae to precisely specify which secret
  inputs, read at which times, may be released. We formalize a
  semantic security condition, \emph{interaction-based
    noninterference}, to define our policies precisely.  Finally, we
  describe a prototype tool that uses symbolic execution to check
  interaction-based declassification policies for Android, and we show
  that it enforces policies correctly on a set of apps.
  \keywords{Information flow, program analysis, symbolic
    execution.}
\end{abstract}

\section{Introduction}
\label{sec:introduction}

Android devices manage sensitive information, such as contacts and
location.  To prevent apps from abusing this information, Android
employs an access control system based on \emph{permissions}, which
are capabilities granted to apps at install time. Unfortunately, once
an app has a permission, it has \emph{carte blanche} to use it in any
way at run time. For example, an app with location and Internet access
could continuously broadcast the device's location.
Thus, permissions do not enable fine-grained control of what and when
sensitive information may be used.

To address that limitation, this paper presents a new framework for
Android app security based on information flow control.  The key idea
behind our framework is that users naturally express their intentions
about information release as they interact with an app.
%\mrc{I don't understand how our formalism
%relates to app state.  This used to be called ``context'', and I grepped
%for ``context'' throughout the rest of the paper, and it never showed up
%again.  Actually, I don't think app state has much to do with our
%work.  Rather, we care about event traces.} 
For example,
%\begin{enumerate}
clicking a button may permit an app to release a phone number over the
Internet. Or, as another example,
toggling a radio button from ``coarse'' to ``fine'' and back to
  ``coarse'' may temporarily permit an app to use fine-grained GPS
  location vs.\ a coarse-grained approximation.
%\end{enumerate}
%Thus, in our framework, the interactions that users have with apps
%determine whether information may be released.

To model these kinds of scenarios, we introduce
\emph{interaction-based declassification policies}, which
extensionally specify what information flows may occur after which
sequences of \emph{events}.  Events are GUI interactions (e.g., a
button click), inputs (e.g., reading
the phone number), or outputs (e.g., a send over the Internet).
A policy is a set of \emph{declassification conditions}, written
$\phi \mathrel\rhd S$, where $\phi$ is a linear-time temporal logic
(LTL)~\cite{Pnueli:1977} formula over events, and $S$ is a sensitivity
level.  If $\phi$ holds at the time an input occurs, then that input
is declassified to level $S$.  (Our declassification policies thus
refine those of Chong and Myers~\cite{Chong:04} by providing a logical
notation for expressing the conditions under which declassification is
permitted.) We formalize a semantic security condition,
\emph{interaction-based noninterference} (IBNI), over sets of event
\emph{traces} generated by an app.  Intuitively, IBNI holds of an app
and policy if observational
determinism~\cite{Zdancewic:03} holds after all inputs have been
declassified according to the policy. 
%\mrc{I'm not sure I have that right.  Kris, what do you think?}  
%\kris{Yes, Michael, that is right, and a good way to think about it!}
(Section~\ref{sec:overview}
describes policies further, and Section~\ref{sec:formalism} presents
our formal definitions.)

%presents two apps and their policies, corresponding to the two
% scenarios above: a Bump app, which releases phone numbers, and a
% location-sharing app, which releases coarse or fine-grained
% locations.)

 % A key hypothesis behind our approach is that \emph{user}
% interactions should control information flow
% \cite{Roesner:12,Chen:13}.

% Our policies can also reason about when secrets are accessed, e.g.,
% ``Only locations read when the \emph{map} option is selected are
% declassified.''

% Extensional policies are critical to our approach, because they allow
% us to control how sensitive inputs are released based on the user's
% interaction, rather than the implementation of the app.

We introduce \toolname, a prototype tool that analyzes
whether an Android app and its declassification policy
satisfies IBNI.
\toolname generates event traces using SymDroid~\cite{Jeon:2012}, a
Dalvik bytecode symbolic executor.  \toolname
simulates user interactions with the app.
%, and it includes a manually written
%model of the Android framework to support symbolic execution.
% \jeff{I think we should keep the above to remind readers it is a
% contribution of this work. Like most introduction text, they will
% need to read the rest of the paper to get the full details.}
% \mrc{I still don't understand what it means, and the introduction
% is a bad time to lose a reader.  Can we elaborate?}
In practice, it is not feasible to
enumerate all program traces, so \toolname generates traces up to some
\emph{input depth} of $n$ GUI events.  
\toolname{} then synthesizes a
set of logical formulae that hold if and only if IBNI holds, and uses
Z3~\cite{deMoura:2008} to check their satisfiability.
(Section~\ref{sec:implementation} describes \toolname in detail.)

% \rsout{\toolname uses a per-app driver to inject the events into the
%   app, and it includes a manually written model of the Android
%   framework to support symbolic execution of calls into and out of the
%   framework.}  \mrc{The previous sentence doesn't communicate enough
%   information to be understood by the reader at this point.  The
%   alternatives are expanding to about three sentences, or cutting it.
%   I favor cutting it.} 

To validate \toolname, we used it to analyze four Android apps,
including both secure and insecure variants of those apps.
We ran each app variant under a range of input depths, and confirmed
that, as expected, \toolname{} scales exponentially.
However, we manually examined each app and its policy, and
found that an input depth of at most 5 is sufficient to
guarantee detection of a security policy violation (if any) for these
cases.  We ran \toolname{} at these minimum input depths and found
that it correctly passes and fails the secure and insecure app
variants, respectively. At these depths, \toolname{} takes just a few
seconds to run. (Section~\ref{sec:experiments} describes our experiments.)

In summary, we believe that \toolname takes an important step forward
in providing powerful new security mechanisms for mobile devices.

% In summary the contributions of this paper are:
% * We present a new framework for security policies in Android we call
% interaction-based declassification policies. The key idea: app context
% determines what information flows may occur.
% * We give a formal security definition of noninterference for our policies in terms of
% traces of program events, where events are extensionally defined
% * We describe a prototype tool that uses symbolic execution to extract
% traces from Android apps and then directly checks whether
% noninterference is satisfied
% * We ran on four subject programs with both secure and insecure
% variants. We find our tool is able to bin correctly. As expected,
% memory and running time scale exponentially with the number of
% simulated events. But, the max necessary number of events is small and
% tractable.

%  Moreover, specifying policies extensionally (events
% correspond to app inputs and outputs, rather than internal state),
% we

\section{Example Apps and Policies}
\label{sec:overview}

We begin with two example apps that show interesting aspects of
interaction-based declassification
policies.

\subsection{Bump app}

The boxed portion of Fig.~\ref{fig:app-bump} gives (simplified) source
code for an Android app that releases a device's unique ID and/or phone
number. This app is inspired by the Bump app, which let users tap
phones to share selected information with each other.  We have
interspersed an insecure variant of the app in the red code on
lines~\ref{line:bump-evil1} and \ref{line:bump-evil2}, which we will
discuss in Section~\ref{sec:traces}.

Each screen of an Android app is implemented using a class that
extends \code{Activity}. When an app is launched, Android invokes the
\code{onCreate} method for a designated main activity.
(This is part of the \emph{activity lifecycle}~\cite{Android:15},
% \jeff{missing cite!} \kris{Citing correctly now I think..}
which includes several methods called in a certain order. For this
simple app, and the other apps used in this paper, we only need a
single activity with this one lifecycle method.)
That method retrieves
(lines~\ref{line:bump-button}--\ref{line:bump-check}) the GUI IDs of a
button (marked ``send'') and
two checkboxes (marked ``ID'' and ``phone''). The \code{onCreate} method next
gets an instance of the \code{TelephonyManager}, uses it
to retrieve the device's unique ID and phone number information, and unchecks the two
checkboxes as a default. Then it creates a new callback
(line~\ref{line:bump-cb}) to be invoked when the ``send'' button is
clicked. When called, that callback releases the user's ID and/or
phone number, depending on the checkboxes.

\begin{figure}[t]
\centering
%\begin{tabular}{ccc}
%\begin{minipage}[c]{0.45\textwidth}
  \begin{lstlisting}[name=Ex]
public class BumpApp extends Activity {
 protected void onCreate(...) {
  Button sendBtn = (Button) findViewById(...); /**\label{line:bump-button}*/
  CheckBox idBox = (CheckBox) findViewById(...);
  CheckBox phBox = (CheckBox) findViewById(...);/**\label{line:bump-check}*/
  TelephonyManager manager = TelephonyManager.getTelephonyManager(); /**\label{line:bump-tele}*/
  final int id = manager.getDeviceId(); /**\label{line:bump-id}*/
  final int ph = manager.getPhoneNumber();
  idBox.setChecked(false);
  phBox.setChecked(false);
  sendBtn.setOnClickListener(
   new OnClickListener() { /**\label{line:bump-cb}*/
    public void onClick(View v) {
     if (idBox.isChecked())
      Internet.sendInt(id);  /**\label{line:bump-benign1}*/      
      /**\textcolor{red}{//Internet.sendInt(ph);} */ /**\label{line:bump-evil1}*/
     if (phBox.isChecked())
      Internet.sendInt(ph); /**\label{line:bump-benign2}*/
      /**\textcolor{red}{//Internet.sendInt(id);} */ /**\label{line:bump-evil2}*/
}})}}
  \end{lstlisting}
\begin{displaymath}
  \begin{array}{cc}
      \code{id}!\ast \wedge (\tfuture ( \code{sendBtn!unit} \land
      \tlast{\code{idBox}}{\code{true}})) \rhd Low, \\

      \code{ph}!\ast \wedge (\tfuture (
      \code{sendBtn!unit} \land
      \tlast{\code{phBox}}{\code{true}})) \rhd Low \\
    \end{array}
\end{displaymath}
\caption{``Bump'' app and policy.}
\label{fig:app-bump}
%\end{minipage}
% &
%\hspace*{0.01\textwidth}
%&
%\begin{minipage}[c]{0.45\textwidth}
%\end{minipage}
%\end{tabular}
%\caption{Example apps.}
\end{figure}
 
This app is written to work with \toolname{}, a symbolic execution tool we built to check
whether apps satisfy interaction-based declassification policies. As we
discuss further in Section~\ref{sec:implementation}, \toolname{} uses an
executable model of Android that abstracts away some details that are
unimportant with respect to security. While a real app would release
information by sending it to a web server, here we instead call a
method \code{Internet.sendInt}. Additionally, while real apps
include an XML file specifying the screen layout of buttons,
checkboxes, and so on, \toolname{} creates those GUI elements
on demand at calls to \code{findViewById} (since their screen locations are
unimportant). Finally, we model the ID and phone number as
integers to keep the analysis simpler.

\toolname{} symbolically executes paths through subject apps, recording a
\emph{trace} of \emph{events} that correspond to certain method calls.
% In
%\toolname{}, events 
%mark GUI inputs, secret inputs, and network sends.
For example, one path through this app generates a trace
\begin{displaymath}
   \code{id!42}, \code{ph!43}, \code{idBox!true},
    \code{sendBtn!unit}, \code{netout!}\code{42}
\end{displaymath}
Each event has a \emph{name} and a \emph{value}. Here we have used
names \code{id} and \code{ph} for secret inputs, \code{idBox} and
\code{sendBtn} for GUI inputs, and \code{netout} for the network
send.  In particular, the trace above indicates 42 is read as the ID,
43 is read as the phone number, the ID checkbox is selected, the send
button is clicked (carrying no particular value, indicated by
\code{unit}), and then 42 is sent on the network. In \toolname{},
events are generated by calling certain methods that are specially
recognized. For example, \toolname{} implements the
\code{manager.getDeviceId} call as both returning a value and emitting
an event.

Notice here that in the trace, callbacks to methods such as
\code{idBox} and \code{sendBtn} correspond to user
interactions. The key idea behind our framework is that these actions
convey the user's intent as to which information should be
released. Moreover, traces also contain actions relevant to
information release---here the reads of the ID and phone number, and
the network send. Thus, putting both user interactions and
security-sensitive operations together in a single trace allows
our policies to enforce the user's intent.

The policy for
this example app is shown at the bottom of Fig.~\ref{fig:app-bump}.
Policies are comprised of a set of \emph{declassification
  conditions} of the form $\phi \rhd S$, where $\phi$ is an LTL
formula describing event traces and $S$ is a security level.  Such a
condition is read, ``At any input event, if $\phi$ holds at that
position of the event trace, then that input is declassified at level
$S$.''  For this app there are two declassification conditions. The
top condition declassifies (to \emph{Low}) an input that is a
read of the ID at any value (indicated by $\ast$), if
sometime in the future (indicated by the $\tfuture$ modality) the send
button is clicked and, when that button is clicked, the last value of
the ID checkbox was \code{true}. (Note that \emph{last} is not
primitive, but is a macro that can be expanded into regular LTL.)  The
second declassification condition does the analogous thing for the
phone number.

To check such a policy, \toolname{} symbolic executes the program,
generating per-path traces; determines the classification level of every input; and
checks that every pair of traces satisfies noninterference.
Note that using LTL provides a very general and
expressive way to describe the sequences of events that imply
declassification. For example, here we precisely capture that
only the last value of the checkbox matters for declassification. For
example, if a user selects the ID checkbox but then unselects it
and clicks send, the ID may not be released.

Also notice this policy depends on the app reading the ID
and phone number when the app starts. If the app instead
waited until after the send button is clicked, it would violate this
policy. We could address this by replacing the $\tfuture$ modality by
$\tpast$ (past) in the policy (and we could form a disjunction of the
two policies if we wanted to allow either). More generally, we
designed our framework to be sensitive to such choices to
support  reasoning about secret
values that change over time, so we can precise specify the level of a
secret input that was read at a particular time. We will see an
example next.

\subsection{Location resolution toggle app}

\begin{figure}[t]
\centering
\begin{lstlisting}[name=Ex]
public class ToggleRes extends Activity { ...
 LocSharer mLocSharer = new LocSharer();
 RadioManager mRadio = new RadioManager();
 protected void onCreate(...) { ... }
 private class LocSharer implements LocationListener { ... 
  public LocSharer(RadioManager rm) {
   lm = (LocationManager) getSystemService(LOCATION_SERVICE);
   lm.requestLocationUpdates(mCurrentProvider, SHARE_INTERVAL, distance, this);
  }
  public void onLocationChanged(Location l) {
   if (mRadio.mFine) {
    Internet.sendInt(l.mLatitude);
    Internet.sendInt(l.mLongitude);
   } else {
    Internet.sendInt(l.mLatitude & 0xffffff00);
    Internet.sendInt(l.mLongitude & 0xffffff00);
 } } }
 private class RadioManager
  implements OnClickListener {
   public boolean mFine = false;
   public void onClick(View v) { mFine = !mFine; }
} }
\end{lstlisting}
  \begin{displaymath}
    \begin{array}{ll}
    \code{longitude}!\ast \wedge
    \tlast{\code{mRadio}}{\code{true}} \rhd
    \textit{Low}, \\
    \code{longitude}!\ast \wedge
    \tlast{\code{mRadio}}{\code{false}} \rhd
    \textit{MaskLower8}
    \end{array}
  \end{displaymath}
\caption{Location sharing app and policy.}
\label{fig:app-loc-toggle}
\end{figure}

Fig.~\ref{fig:app-loc-toggle} gives code for an app that
shares location information, either at full or truncated resolution
depending on the setting of a radio button. The app's \code{onCreate}
method displays a radio button (code not shown) and then creates and
registers a new instance of \code{RadioManager} to be called
each time the radio button is changed. That
class maintains a field \code{mFine} as \code{true} when the radio button is
set to full resolution and \code{false} when it is set to truncated
resolution.

Separately, \code{onCreate} registers \code{LocSharer} to be called
periodically with the current location.  It requests location updates
by registering a callback with the \code{LocationManager}
system service.  When called, \code{LocSharer} releases the
location, either at full resolution or with the lower 8 bits
masked, depending on \code{mFine}.

The declassification policy for longitude appears below the code; the
policy for latitude is analogous.  This policy allows the precise
longitude to be released when
\code{mRadio} is set to fine, but only the lower eight bits to
be released if \code{mRadio} is set to coarse. Here \toolname{}
knows that at the \textit{MaskLower8} level, it should consider
outputs to be equivalent up to differences in the lower 8
bits. 

Finally, notice that this policy does not use the future
modality. This is deliberate, because location may be read multiple
times during the execution, at multiple values, and the security level
of those locations should depend on the state of the
radio button at that time. For example, consider a trace
\begin{displaymath}
   \code{mRadio!false}, \code{longitude!}v_1,
    \code{mRadio!true}, \code{longitude!}v_2
\end{displaymath}
The second declassification condition ($\code{longitude}!\ast \wedge
\tlast{\code{mRadio}}{\code{false}}$) will match the event with $v_1$, since
the last value of \code{mRadio} was \code{false}, and
thus $v_1$ may be declassified only to \textit{MaskLower8}. Whereas
the first declassification condition will match the event with $v_2$, hence it
may be declassified to \textit{Low}.

\section{Program Traces and Security Definition}
\label{sec:formalism}

Next, we formally define when a set of program traces satisfies an
interaction-based declassification policy.

% The examples in Section~\ref{sec:overview} highlighted several
% language features that are relevant to interaction-based declassification
% policies. Apps register callbacks that are invoked when a GUI element
% is clicked.  Secret information comes in either via direct calls
% (e.g., \code{manager.getDeviceId} in Fig.~\ref{fig:app-bump}) or
% callbacks (e.g., \code{onLocationChanged} in
% Fig.~\ref{fig:app-loc-toggle}).  To define our interaction-based
% declassification conditions, we first model apps as sequences of these
% events that occur in concrete executions.

\subsection{Program Traces}
\label{sec:traces}

\begin{figure}[t!]
  \small
  \centering
  \begin{displaymath}
    \begin{array}{p{1in}lrl}
      Primitives & \xv & ::= & n \mid \strue \mid \sfalse \mid \sunit \mid f(\xv_1, \ldots, \xv_i) \\
      Events & \evt & ::= & \sch ! p \\
      Traces & t & ::= & \evt ~ \textit{list} \\
      \\
      \multicolumn{4}{c}{\textrm{(a) Event and Trace Definitions.}} \\
      \\
      Policies & P & ::= & C_1, C_2, \ldots \\
      Conditions & C & ::= & \phi \rhd S\\
      Security Levels & S & ::= & \textit{High} \mid \textit{Low} \mid
      \textit{MaskLower8} \mid \ldots \\
      Atoms & \atom & ::= & \sch!s \mid s \oplus s \\
      Messages & s & ::= & x \mid p \mid \ast \\
      Formulae & \phi & ::= &
      \atom
      \mid \neg \phi
      \mid \phi \wedge \phi
      \mid \phi \vee \phi
      \mid \phi \limplies \phi
      \mid \exists x.\phi 
      \mid \forall x.\phi \\
      && \mid  & \tnext \phi
      \mid \phi \tuntil \phi
      \mid \talways \phi
      \mid \tfuture \phi
      \mid \phi \tsince \phi
      \mid \tpast \phi \\
      \\
      \multicolumn{4}{c}{\textrm{(b) Interaction-based Declassification Policy Language.}}
    \end{array}
  \end{displaymath}
  \caption{Formal definitions.}
  \label{fig:formalism}
\end{figure}

Fig.~\ref{fig:formalism}(a) gives the formal syntax of events and
traces.  \emph{Primitives}~$p$ are terms that can be carried by
events, e.g., values for GUI events, secret input returns, or network
sends.  In our formalism, primitives are integers, booleans, and terms
constructed from primitives using uninterpreted constructors $f$.  As
programs execute, they produce a \emph{trace}~$\tr$ of
\emph{events}~$\evt$, where each event $\sch!p$ pairs an event name
$\sch$ with a primitive $p$. We assume event names are partitioned
into those corresponding to inputs and those corresponding to
outputs. For all the examples in this paper, all names are inputs
except \code{netout}, which is an output.

Due to space limitations, we omit details of how traces are
generated. Instead, we simply assume there exists some set
$\tset$ containing all possible traces a given program may
generate.
%
%   As we explain in
% Section~\ref{sec:implementation}, we use \toolname{} to model the set
% $\traces(e)$ by associating method calls in Java with events in our
% model.  \kris{This is still unclear, needs explaining.} Here, we use
% $\traces(e)$ to define noninterference for our apps, and leave its
% definition abstract. \kris{Right now I have a $\judge$ form in here.
%   Should I discuss it here?  Or can I just leave it out.  We want to
%   talk about apps as being a set of traces, but we probably don't want
%   to deal with the nastiness of discussing concrete vs. symbolic}
%
For example, consider the insecure variant bump app in
Fig.~\ref{fig:app-bump}, which removes lines \ref{line:bump-benign1}
and \ref{line:bump-benign2} and uncomments lines \ref{line:bump-evil1}
and \ref{line:bump-evil2}.  This app sends the phone number when the
email box is checked and vice-versa. Thus, its set $\tset$
contains, among others, the following two traces:
\begin{displaymath}
  \begin{array}{cl}
    \code{id}!0, \code{ph}!0, \code{idBox}!\code{true},
    \code{sendBtn}!\code{unit}, \code{netout}!0 & (1) \\
    \code{id}!0, \code{ph}!1, \code{idBox}!\code{true},
    \code{sendBtn}!\code{unit}, \code{netout}!1 & (2) \\
  \end{array}
\end{displaymath}%
\lstset{language=Java}%
In the first trace, ID and phone number are read as 0, the
ID checkbox is selected, the button is clicked, and 0 is sent.
The second trace is similar, except the phone number and sent value
are 1. Below, we use these traces to show this program
violates its security policy.
% In Section~\ref{sec:implementation}, we
%show how to generate trace sets using symbolic execution.

\subsection{Interaction-based Declassification Policies}
\label{sec:policies}

We now define our policy language precisely.
Fig.~\ref{fig:formalism}(b) gives the formal syntax of
declassification policies.  A policy $P$ is a set of
\emph{declassification conditions} $C_i$ of the form $\phi_i\rhd S_i$,
where $\phi_i$ is an LTL formula describing when an input is
declassified, and $S_i$ is a \emph{security level} at which the value
in that event is declassified.

As is standard, security levels $S$ form a lattice.  For our
framework, we require that this lattice be finite.  We include
\textit{High} and \textit{Low} security levels, and we can generalize
to arbitrary lattices in a straightforward way. Here we include the
\textit{MaskLower8} level from Fig.~\ref{fig:app-loc-toggle} as an
example, where $\textit{Low} \sqsubseteq \textit{MaskLower8}
\sqsubseteq \textit{High}$.  Note that although we include
\textit{High} in the language, in practice there is no reason to
declassify something to level \textit{High}, since then it remains
secret.

The \emph{atomic predicates}~$A$ of LTL formulae match events,
e.g., atomic predicate $\sch!p$ matches exactly that event.
We include $\ast$ for matches to
arbitrary primitives. We allow event values to be
variables that are bound in an enclosing quantifier. The atomic
predicates also include the ability to make atomic arithmetic
statements.  
The combination of these lets us describe complex
events. For example, we could write
$\exists x. \textit{spinner}!x \wedge x > 2$ to indicate the
\emph{spinner} was selected with a value greater than 2.

Atomic predicates are combined with the usual boolean connectives
($\neg$, $\wedge$, $\vee$, $\rightarrow$) and existential and
universal quantification.  Formulae include standard LTL
modalities $\tnext$ (next), $\tuntil$
(until), $\talways$ (always), $\tfuture$ (future), $\phi \tsince \psi$
(since), and $\tpast \phi$ (past).  Formulae also include
$\tlast{\sch}{p}$, which is syntactic sugar for $\lnot (\sch!\ast)
\tsince \sch!p$.
We assume a standard interpretation of LTL formulae over
traces \cite{Lichtenstein:85}.
We write $\tr, i \models \phi$ if trace $\tr$ is a model of $\phi$ at
position $i$ in the trace.

% \begin{figure}[!t]
%   \small
%   \begin{displaymath}
%     \begin{array}{rcl}
%       P & ::= & C_1, C_2, \ldots \\
%       C & ::= & \phi \rhd S\\
%       S & ::= & \textit{High} \mid \textit{Low} \mid
%       \textit{MaskLower8} \mid \ldots \\
%       \atom & ::= & \sch?s \mid \sch!s \mid s \oplus s \\
%       s & ::= & x \mid p \mid \ast \\
%       \phi & ::= &
%       \atom
%       \mid \neg \phi
%       \mid \phi \wedge \phi
%       \mid \phi \vee \phi
%       \mid \phi \limplies \phi
%       \mid \exists x.\phi 
%       \mid \forall x.\phi
%       \mid  \tnext \phi
%       \mid \phi \tuntil \phi
%       \mid \talways \phi
%       \mid \tfuture \phi
%       \mid \phi \tsince \phi
%       \mid \tpast \phi \\
%     \end{array}
%   \end{displaymath}
%   \caption{GUI-based Declassification Policy Language.}
%   \label{fig:policy-temporal-logic}
% \end{figure}

% \begin{displaymath}
%   \begin{array}{c}
%     \code{email}?v \land \big( \tfuture ( \code{button} = () \land 
%     last(\code{email\_released})=\code{true} \big) \rhd L, \\

%     \code{email}?v \land \big( \tfuture ( \code{button} = () \land 
%     last(\code{email\_released})=\code{true} \big) \rhd L, \\
%   \end{array}
% \end{displaymath}

% Policies associate inputs with security levels, which roughly assert
% what an observer is allowed to learn about that input.  Our system has
% a finite (but arbitrarily large) set of security levels (with
% metavariable $L$ in figure~\ref{fig:policy-temporal-logic}) with at
% least the levels $H$ (high security) and $L$ (low security).  Low
% security inputs are public: the observer is allowed to know their
% values.  High security inputs are private: the observer is never
% allowed to know anything about their values.  This is subsequently
% made formal in section~\ref{}.

Next consider a trace $\tr \in \tset$ for an arbitrary program.
We write $\tlevel{\tr}{P}{i}$ for the security level that policy
$P$ assigns to the event $\tr[i]$:

\begin{displaymath}
  \tlevel{\tr}{P}{i} =
  \begin{cases}
    \bigsqcap_{\phi_j\rhd S_j \in P} \aset{ S_j \mid \tr, i \models
      \phi_j } & \tr[i] = \sch!p \\
    \textit{Low} & \tr[i] = \sch!\code{netout} \\
  \end{cases}
\end{displaymath}

In other words, for inputs, we take the greatest lower bound (the most
declassified) of the levels from all declassification conditions that
apply. We always consider network outputs to be
declassified. Notice that if no policy applies, the level is $H$ by
definition of greatest lower bound.

For example, consider trace (1) above with
respect to the policy in Fig.~\ref{fig:app-bump}.  At position 0, the
LTL formula holds because the ID box is eventually checked and then
the send button is clicked, so $\tlevel{(1)}{P}{0} =
\textit{Low}$. However,
$\tlevel{(1)}{P}{1} = \textit{High}$ because no
declassification condition applies for \code{ph}
(\code{phBox} is never checked). And $\tlevel{(1)}{P}{4} =
\textit{Low}$, because that position is a network send.

Next consider applying this definition to the GUI inputs. As written,
we have $\tlevel{(1)}{P}{2}$ = $\tlevel{(1)}{P}{3}$ =
\textit{High}. However, our app is designed to leak these inputs. 
For example, an adversary will learn the state of
\code{idBox} if they receive a message with an ID. Thus,
for all the subject apps in this paper, we also declassify all GUI inputs as
\textit{Low}. 
For the example in Fig.~\ref{fig:app-bump}, this means
adding the conditions
$\code{idBox!}\ast \rhd \textit{Low}$,
$\code{phBox!}\ast \rhd \textit{Low}$, and
$\code{sendBtn!}\ast \rhd \textit{Low}$. In general, 
the security policy designer should decide the security level of GUI inputs.

Next, we can apply \textit{level} pointwise across a trace and discard
any trace elements that are below a given level $S$. We define
\begin{displaymath}
\tleveltr{\tr}{P}^S[i] =
\begin{cases}
\tr[i] & \tlevel{\tr}{P}{i} \sqsubseteq S \\
\tau & \textrm{otherwise}
\end{cases}
\end{displaymath}
We write $\tleveltr{\tr}{P}^{S,in}$ for the same filtering, except
output events (i.e., network sends) are removed as well.
%
Considering the traces (1) and (2) again, we have

\begin{displaymath}
  \begin{array}{r@{ }c@{ }l}
    \tleveltr{(1)}{P}^\textit{Low} & = & \code{id}!0, \code{idBox}!\code{true},
    \code{sendBtn}!\code{unit}, \code{netout}!0 \\
    \tleveltr{(2)}{P}^\textit{Low} & = & \code{id}!0, \code{idBox}!\code{true},
    \code{sendBtn}!\code{unit}, \code{netout}!1 \\
    \tleveltr{(1)}{P}^\textit{Low,in} & = & \code{id}!0, \code{idBox}!\code{true},
    \code{sendBtn}!\code{unit} \\
    \tleveltr{(2)}{P}^\textit{Low,in} & = & \code{id}!0, \code{idBox}!\code{true},
    \code{sendBtn}!\code{unit} \\
  \end{array}
\end{displaymath}

Finally, we can define a program to satisfy noninterference if, for
every pair of traces such that the inputs at level $S$ are the same,
the outputs at level $S$ are also the same.
%
To account for generalized lattice levels such as \textit{MaskLower8},
we also need to treat events that are equivalent at a certain level as
the same. For example, at \textit{MaskLower8}, outputs
\bcode{0xffffffff} and \bcode{0xffffff00} are the same, since they do
not differ in the upper 32 bits. Thus, we assume for each security
level $S$ there is a appropriate equivalence relation $=_S$, e.g., for
\textit{MaskLower8}, it compares elements ignoring their lower 8
bits. Note that $x =_\textit{Low} y$ is simply $x = y$ and
$x =_\textit{High} y$ is always true.

\begin{definition}[Interaction-based Noninterference (IBNI)]
  \label{defn:noninterference}
  A program satisfies security policy $P$, if for all $S$ and for
  all $t_1, t_2 \in
      \tset$ (the set of traces of the program) the following holds:
\begin{displaymath}
    \tleveltr{\tr_1}{P}^{S,in} =_S \tleveltr{\tr_2}{P}^{S,in}
    \implies
    \tleveltr{\tr_1}{P}^S =_S \tleveltr{\tr_2}{P}^S \\
\end{displaymath}
\end{definition}

Looking at traces for the insecure app, we see
they violate non-interference, because
$\tleveltr{(1)}{P}^\textit{Low,in} =
\tleveltr{(2)}{P}^\textit{Low,in}$, but
$\tleveltr{(1)}{P}^\textit{Low} \neq \tleveltr{(2)}{P}^\textit{Low}$
(they differ in the output).  We note that our definition of
noninterference makes it a 2-hypersafety property \cite{Clarkson:10}.

  
% \subsection{Enforcing policies using symbolic execution}
% \label{sec:symbolic}

% Our semantics for programs (presented in section~\ref{sec:formalism})
% generates sets of symbolic traces, $\tset$.  These traces contain
% symbolic variables on their input channels, some of which must be
% constrained to satisfy the policy.  We now describe how to check a set
% of symbolic traces to see that it satisfies a policy $P$.  From the
% set $\tset$, we form a set of obligations that are sent to an SMT
% solver.  The formulas will mention symbolic inputs and generate
% formulas which will subsequently be checked for satisfiability.  We
% generate our equations so that if the solver returns a satisfiable
% solution, a counterexample can be derived, and if the equations are
% not satisfiable, the program satisfies the policy.

% Programs read inputs along their internal channels, some of which are
% secret (as disignated by the policy $P$).  The extensional policy we
% enforce is to show that, for (subsequences of) any two structurally
% equivalent traces $\tr_1$ and $\tr_2$, if the low observable input is
% the equal, then the sequences of low observable events are the same.
% Because we are using an SMT solver, we instead check if there are any
% traces where we might be able to find a \emph{inequivalent} sequence
% of outputs, given our assumptions about the inputs.  For each pair of
% symbolic traces in $\tset \times \tset$, we assemble the formula
% $test(P,\tr_1, \tr_2')$\footnote{$\tr_2'$ is the trace with the same
%   structure as $\tr_2$, but whose variables have all been replaced by
%   their primed analogs}:

%% \subsection{Policies for our programs in HyperLTL2}

%% \jeff{Not sure what goes in this section}

%% To relate our policies to more traditional information flow policies,
%% we use the language of HyperLTL2.  HyperLTL2 is a logic for stating
%% information flow policies for systems that allows quantification over
%% traces and temporal logic statements about relations between traces.

%% \begin{Definition}[Concretized trace sets]
%%   From a symbolic trace set $\overrightarrow{\tr}$, we can obtain a
%%   (potentially infinite) set of concrete traces,
%%   $\gamma(\overrightarrow{\tr})$.  We define this set as follows: for
%%   all traces $\tr$ containing only concrete values on its channels,
%%   $\tr \in \gamma(\overrightarrow{\tr})$ if and only if the path
%%   condition for $\tr$ is satisfiable when the symbolic variables are
%%   instantiated with the concrete assignments from the corresponding
%%   positions (via its messages) in $\tr$.
%% \end{Definition}

%% \begin{Definition}[Noninterference]
%%   A program $e$ satisfies noninterference with respect to a policy $P$
%%   if:

%%   \forall \tr_1, \tr_2.  \tr_1 \equiv_{L,in} \tr_2 \implies \tr_1
%%   \equiv_{L} \tr_2
%% \end{Definition}

\section{Implementation}
\label{sec:implementation}

We built a prototype tool, \toolname{} to check whether Android apps obey the
interaction-based declassification policies described in
Section~\ref{sec:formalism}. \toolname{} is based on
SymDroid~\cite{Jeon:2012}, a symbolic executor for Dalvik bytecode,
which is the bytecode format to which Android apps are compiled.
As is standard, SymDroid computes with \emph{symbolic
  expressions} that may contain \emph{symbolic variables}
representing sets of values. At conditional branches that depend on
symbolic variables, SymDroid invokes Z3~\cite{deMoura:2008} to
determine whether one or both branches are feasible. As it follows
branches, SymDroid extends the current \emph{path condition}, which tracks
branches taken so far, and forks execution when multiple paths are
possible. Cadar and Sen~\cite{Cadar:13} describe
symbolic execution in more detail.

SymDroid uses the features of symbolic execution to implement
nondeterministic event inputs (such as button clicks or spinner
selections), up to a certain bound. Since we have symbolic variables
available, we also use them to represent arbitrary secret inputs in a
compact way. There are several issues that arise in applying SymDroid
to checking our policies, as we discuss next.

\subsection{Driving App Execution}
\label{sec:driver}

%% Our formal model has built-in notions of callbacks, the message
%% queue, and non-deterministic inputs.

Android apps use the platform's API, which includes
classes for responding to events via callbacks.
On Android, those features are part of the
framework.  We could try to symbolically execute Android framework code
directly, but past experience suggests this is intractable, since the
framework is large, complicated, and includes native code.
Instead, we created an \emph{executable model}, written in Java, that
mimics key portions of Android needed by our subject apps. Our Android
model includes facilities for generating clicks and
other GUI events (such as the \code{View}, \code{Button}, and
\code{CheckBox} classes, among others). It also includes code for
\code{LocationManager},
\code{TelephonyManager}, and other basic Android classes.

In addition to code modeling Android, the model also
includes simplified versions of Java library classes such as
\code{StringBuffer} and \code{StringBuilder}.  Our versions of
these APIs implement unoptimized versions of methods in
Java and escape to internal SymDroid functions to handle operations that
would be unduly complex to symbolically execute. For instance, SymDroid
represents Java \code{String} objects with OCaml strings instead of
Java arrays of characters. It thus models methods such as \code{String.concat}
with internal calls to OCaml string manipulation functions. Likewise,
reflective methods such as \code{Class.getName} are handled internally.

For each app, we created a driver that uses our Android model to simulate user
input to the GUI. The driver is specific to the app since it depends on the
app's GUI.  The driver begins by calling the app's \code{onCreate}
method. 
% It then calls SymDroid internal methods to set up a map from the GUI
% elements to event names.
Next it invokes special
methods in the Android model to inject GUI events. There is one such method for
each type of GUI element, e.g., buttons, checkboxes, etc. 
For example,
\code{Trace.addClick(id)} generates a click event for the given
\code{id} and then calls the appropriate event handler.
The trace entry contains the event name for that kind of element,
and a value if necessary. 
%The value could indicate, for
%instance, which element was selected from a spinner.
Event handlers are those
that the app registered through standard Android framework mechanisms,
e.g., in \code{onCreate}.

%The driver retrieves those ids from public fields in
%the apps, e.g., from \code{BumpApp.sendBtn} for the app in
%Fig.~\ref{fig:app-bump}. 
%(All of our subject apps store these ids in
%public fields initialized in \code{onCreate}.)

% It then associates a set of GUI elements in the application with
% channels, so that when clicks are made to a button, a click event
% can be recorded in the trace corresponding to the corresponding
% channel.  Each driver program associates GUI elements with channels:
% for example, in the bump app, the \code{sendBox} button is
% associated with the \code{sendBtn} channel, so that whenever that
% button is clicked a \code{unit} value is sent along the
% \code{sendBox} channel.  This will subsequently be used to check the
% policy for the bump app.

Let $m$ be the number of possible GUI events.  To simulate one
arbitrary GUI event, the driver uses a block that branches $m$
ways on a fresh symbolic variable, with a different GUI action
in each branch.  Typical Android apps never exit unless the framework
kills them, and thus we cannot explore all possible program
traces. Instead, the user specifies an \emph{input depth}~$n$, and the
driver runs the GUI event block $n$ times, branching on a fresh
symbolic variable each time. Thus, in total, the driver will execute
at least $m^n$ paths.

\subsection{Symbolic Variables in Traces}
\label{sec:symbolic-traces}

% maintains a trace of input
% and output events, corresponding to the traces from
% Section~\ref{sec:formalism}. Internally, the Android model calls various
% specially recognized methods to emit events. 
% When SymDroid sees such a call, it adds the event to the trace
% for the current program path. Thus, a complete path explored by
% SymDroid is a 

% When the driver for each program sets up the program state, it
% associates certain GUI elements with channel names by calling into
% SymDroid with a button ID, where it is stored in a map from IDs to
% channel names.  When SymDroid sees the entry of a method corresponding
% to a GUI event (such as a button click or checkbox toggle), it loooks
% up the identifier of the GUI element in the map set up by the driver,
% and appends an event in the trace it records in the path's trace.

In addition to GUI inputs, apps also use secret inputs. We could use
SymDroid to generate concrete secret inputs, but instead we opt to use
a fresh symbolic variable for each secret input. For example, the call
to \code{manager.getDeviceId} in Fig.~\ref{fig:app-bump} returns a
symbolic variable, and the same for the call to
\code{manager.getPhoneNumber}. This choice makes checking policies
using symbolic execution a bit more powerful, since, e.g., a symbolic
integer variable represents an arbitrary 32-bit integer. Note that
when \toolname generates a symbolic variable for a secret input, it
also generates a trace event corresponding to the input.

Recall that secret inputs may appear in traces, and thus traces may
now contain symbolic variables. For example, using $\alpha_i$'s as
symbolic variables for the secret ID and phone number inputs, the
traces (1) and (2) become

\begin{displaymath}
  \begin{array}{cl}
    \code{id}!\alpha_1, \code{ph}!\alpha_2, \code{idBox}!\code{true},
    \code{sendBtn}!\code{unit}, \code{netout}!\alpha_2 & (1') \\
    \code{id}!\alpha_1, \code{ph}!\alpha_2, \code{idBox}!\code{true},
    \code{sendBtn}!\code{unit}, \code{netout}!\alpha_2 & (2') \\
  \end{array}
\end{displaymath}

Note we must take care when symbolic variables are in traces.
Recall \textit{level} checks $t,i \models \phi$ and
then assigns a security level to position $i$. If $\phi$
depends on symbolic variables in $t$, we may not be able to
decide this. For example, if the third element in $(1')$ were
$\code{idBox}!\alpha_3$, then we would need to reason with
conditional security levels such as
$\tlevel{\tr}{P}{0} =\textsf{\textbf{if }} \alpha_3 \textsf{\textbf{ then }} \textit{Low}
\textsf{\textbf{ else }} \textit{High}$. We
avoid the need for such reasoning by only using symbolic variables for
secret inputs, and by ensuring the level assigned by a policy does not
depend on the value of a secret input. We leave supporting such
reasoning to future work.

\subsection{Checking Policies with Z3}

Each path explored by SymDroid yields a pair $(t, \Phi)$, where $t$ is
the trace and $\Phi$ is the path condition. \toolname{} uses Z3 to check whether a given set
of such trace, path condition pairs satisfies a policy $P$. Recall that
Definition~\ref{defn:noninterference} assumes for each $S$ there is an
$=_S$ relation on traces. We use the same relation below, encoding it
as an SMT formula. For our example lattice, $=_\textit{High}$ produces
\code{true}, $=_\textit{Low}$ produces a conjunction of equality tests
among corresponding trace elements, and $=_\textit{MaskLower8}$
produces the conjunction of equality tests of the bitwise-and of every
element with \bcode{0xffffff00}.

Given a trace
$t$, let $t'$ be $t$ with its symbolic variables primed, so that the
symbolic variables of $t$ and $t'$ are disjoint. Given a path
condition $\Phi$, define $\Phi'$ similarly. Now we can give the
algorithm for checking a security policy.

\begin{algorithm}
  To check a set $\tset$ of trace, path condition pairs, do the
  following. Let $P$ be the app's security policy. Apply \emph{level}
  across each trace to obtain the level of each event.  For each
  $(t_1, \Phi_1)$ and $(t_2, \Phi_2)$ in $\tset\times\tset$, and for
  each $S$, ask Z3 whether the following formula (the negation of
  Definition~\ref{defn:noninterference}) is unsatisfiable:
  \begin{displaymath}
      \tleveltr{\tr_1}{P}^{S,in} =_S \tleveltr{\tr_2'}{P}^{S,in} \land
      \tleveltr{\tr_1}{P}^S \neq_S \tleveltr{\tr_2'}{P}^S \land
      \Phi_1 \land \Phi_2' \\
  \end{displaymath}
  If no such formula is unsatisfiable, then the program satisfies noninterference.
\end{algorithm}
%
We include $\Phi_1$ and $\Phi'_2$ because they
constrain the symbolic variables in the trace. More precisely,
$\tr_1$ represents a \emph{set} of concrete traces in which its symbolic
variables are instantiated in all ways that satisfy $\Phi_1$,
and analogously for $\tr'_2$.

% Note that our goal is to prove that the noninterference formula from
% Definition~\ref{defn:noninterference} is always true. Hence in the
% algorithm we negate it and check satisfiability. If the negation is
% satisfiable, then noninterference formula does not hold.

If the above algorithm finds an unsatisfiable formula, then Z3 returns a counterexample, which
SymDroid uses to generate a pair of concrete traces
as a counterexample.
For example, consider the traces (1') and (2') above, and prime
symbolic variables in (2'). Those traces have the trivial path
condition \sfmt{true}, since neither branches on a symbolic
input. Thus, the formula passed to Z3 will be:
\begin{displaymath}
    \alpha_1 = \alpha'_1 \land \code{true} = \code{true} \land \sunit = \sunit
    \land
    \big(\alpha_1 \neq \alpha'_1 \vee \code{true} \neq \code{true} \vee
    \sunit \neq \sunit \vee \alpha_2 \neq \alpha'_2 \big)
\end{displaymath}
where the first line is from the equality in the definition and the
second is from the disequality. Thus we can see a satisfying
assignment with $\alpha_1 = \alpha'_1$ and $\alpha_2 \neq \alpha'_2$,
hence noninterference is violated.
% Had this been the correct
%implementation of the app, the last clause of the disjunction would
%have been $\alpha_1 \neq \alpha'_1$, and then the formula would have
%been unsatisfiable.


% A satisfying assignment is any two values of $v_2$ which are not equal
% (Note that $\alpha_1$ and $\alpha_2'$ are not equated because it is
% assigned level $H$ by the policy).  Note that in the benign variant of
% the app (where $\alpha_1$, the id, is sent), the resulting formula
% would be unsatisfiable, because the output would be $v_1$, resulting
% in the formula:

% \begin{displaymath}
%   \begin{array}{c}
%     \alpha_1 = \alpha_1' \land \code{true} = \code{true} \land () = () \land \alpha_1
%     \neq \alpha_1' 
%   \end{array}
% \end{displaymath}

% This formula has no solutions because of the conflict between the
% equality and inequality for $v_1$ and $v_1'$, induced because the
% $level$ assigned the \code{id} input level $L$.

%% \paragraph*{Generating Traces}

%% For each path SymDroid explores, it also maintains a trace of input
%% and output events, corresponding to the traces from
%% Section~\ref{sec:formalism}.

%% In the formalism, messages are either input or output events.  When
%% the driver for each program sets up the program state, it associates
%% certain GUI elements with channel names by calling into SymDroid with
%% a button ID, where it is stored in a map from IDs to channel names.
%% The driver program explores input events nondeterministically by
%% calling methods that mimic these events and generate the corresponding
%% sequence of method calls in Java.  When SymDroid sees the entry of a
%% method corresponding to a GUI event (such as a button click or
%% checkbox toggle), it loooks up the identifier of the GUI element in
%% the map set up by the driver, and appends an event in the trace it
%% records in the path's trace.  In our case, all secret inputs come from
%% classes in Android's framework (such as the \code{Location} class).
%% To generate secret inputs, we modify our model code to generate
%% symbolic variables for fields of these classes, associating them with
%% a designated channel (e.g., the \sfmt{loc} channel).  Then, whenever
%% one of these objects is created, a secret input is recorded in the
%% path's trace.

% When the app instantiates an object or calls a method, SymDroid checks
% to see whether the model contains an implementation for the relevant
% class or method. If it does, SymDroid uses the model version
% instead. For some methods, such as those that affect the visual state
% of controls, the model contains no implementation; in these cases,
% SymDroid treats the method invocation as a no-op.

% Although applications are linked with Android
% runtime library, some library methods (such as those that call out to
% native code in Android) cannot be implemented purely in Java.  These
% calls are intercepted by SymDroid and implemented in OCaml code to
% accurately model their behavior.  As an optmimization, SymDroid also
% models certain methods (such as those that modify GUI buttons) for
% efficiency reasons.

%Our formalism and policies use traces of messages (and LTL formulas
%about them) to define security for applications.  By contrast, Java
%uses callbacks and variables to designate inputs and constructs
%objects and sends them using APIs (e.g., to interact with the
%network).  

% To model input events, the driver designates a certain set of
% callbacks that can be nondeterministically chosen in a toplevel event
% loop.  The app responds to these callbacks by updating the store,
% installing more callbacks, and sending output messages in a way
% similar to our core formalism in section~\ref{sec:formalism}.  Because
% symbolic execution explores only finite unrollings of potentially
% infinite paths, our symbolic execution is parameterized on the number
% of input events to explore.  SymDroid then executes sets of paths up
% to this event bound, and then uses this path set of in its subsequent
% analysis.  Because each event jumps to a set of $k$ handlers (for the
% number of potential events in a given program), the set of paths grows
% exponentially large in the number of events executed.

\subsection{Minimizing Calls to Z3}
\label{sec:z3-tree}

A naive implementation of the noninterference check generates $n^2$
equations, where $n$ is the number of traces produced by \toolname{}
to be checked by Z3. However, we observed that many of these equations
correspond to pairs of traces with different sequences of GUI
events. Since GUI events are low inputs in all our policies, these
pairs trivially satisfy noninterference (the left-hand side of the
implication in Definition~\ref{defn:noninterference} is false).
 Thus, we need not send those
equations to Z3 for an (expensive) noninterference check.

We exploit this observation by organizing SymDroid's output traces
into a tree, where each node represents an event, with
the initial state at the root, and traces with common prefixes share the
same ancestor traces in the tree. We systematically traverse this tree
using a cursor $t_1$, starting from the root. When $t_1$ reaches a new
input event, we then traverse the tree using another cursor $t_2$,
also starting from the root. As $t_2$ visits the tree, we do not
invoke Z3 on any traces with fewer input events than $t_1$ (since they
are not low-equivalent to $t_1$). We also skip any subtrees for
which the root input event differs from the corresponding event in
$t_1$---the trace represented by the root is low-inequivalent to $t_1$,
and extending that trace cannot make it low-equivalent to $t_1$.

% To optimize the number of equations sent to the solver, we represent
% traces as trees of events.  Each node in the trace tree is an event
% and a path condition that holds at the time of that event, along with
% pointers to a set of children nodes.  We must associate events with
% their path conditions because we are representing a set of extended
% traces by the parent relation of the tree \kris{worded badly}.

% To run our analysis, we traverse pairs of paths in this tree starting
% at two nodes $t_1$ and $t_2$ (initially both $t_1$ and $t_2$ are the
% root of the trace tree). If one $t_1$ contains the
% n\textsuperscript{th} output event, we look back in the other path
% $t_2$ to find the n\textsuperscript{th} event.  \kris{If the
%   n\textsuperscript{th} event has not occured we wait until it has.}
% We then form the necessary output inequality, along with a set of
% equations asserting low equality along the paths up to that point
% (obtained by following each node up to the root of the tree).  If the
% paths $t_1$ and $t_2$ cannot be low equal (because, for example, they
% contain a different set of low events up to the n\textsuperscript{th}
% output), we stop traversal and prune this path.  This is sound because
% once two paths are low inequivalent (the antecedent of our
% noninterference definition), no extensions will be low equivalent
% (note that events only move down in the lattice).  Otherwise, we
% assert the equation to the SMT solver and check if the last outputs
% could have been different.  If so, we report the counterexample
% generated.  We then recursively traverse each pair of children from
% $t_1$ and $t_2$.

\section{Experiments}
\label{sec:experiments}

To evaluate \toolname{}, we ran it on four apps, including the two
described in Section~\ref{sec:overview}. We also ran \toolname{} on
several insecure variants of each app, to ensure it can detect the
policy violations. The apps and their variants
are:

\begin{itemize}[leftmargin=*]
\item \textit{Bump.} The bump app and its policy appear in
  Fig.~\ref{fig:app-bump}. The first insecure variant counts clicks to
  the send button sends the value of the
  ID after three clicks, regardless of the state of the ID
  checkbox. The second (indicated in the comments in the program text)
  swaps the released information---if the ID
  box is checked, it releases the phone number, and vice-versa.

\item \textit{Location toggle.} The location toggle app and
  its policy appear in Fig.~\ref{fig:app-loc-toggle}. The first insecure
  variant always shares fine-grained location information, regardless
  of the radio button setting. The second checks if coarse-grain
  information is selected. If so, it stores the fine-grained location
  (but does not send it yet).  If later the fine-grained radio button
  is selected, it sends the stored location. Recall this is forbidden
  by the app's security policy, which allows the release only of locations
  received while the fine-grained option is set.

\item \textit{Contact picker.} We developed a contact picker app
  that asks the user to select a contact from a spinner and then
  click a send button to release the selected contact information over the
  network. The security policy for this app requires that no contact
  information leaks unless it is the last contact selected before the
  button click. (For example, if the user selects contact 1,
  selects contact 2, and then clicks the button, only contact 2 may be
  released.) Note that since an arbitrarily sized list of contacts
  would be difficult for symbolic execution (since then there would be
  an unbounded number of ways to select a contact), we limit the app
  to a fixed set of three contacts.
  The first insecure variant of this app scans the set of contacts for a
  specific one. If found, it sends a message revealing that contact
  exists before sending the actual selected contact. The second insecure
  variant sends a different contact than was selected.
%The second insecure variant selects the subsequent contact in
%the list (rather than the selected contact) and sends it to the
%network.

\item \textit{WhereRU.} Lastly, we developed an app
  that takes push requests for the user's location and shares it depending
  on user-controlled settings.
  The app contains a radio group with three buttons, ``Share Always,'' ``Share
  Never,'' and ``Share On Click.'' There is also a ``Share Now'' button that
  is enabled when the ``Share On Click'' radio button is selected.  When a
  push request arrives, the security policy allows sharing if (1) the ``Always''
  button is selected, or (2) the ``On Click'' button is selected and the user
  presses ``Share Now.'' Note that, in the second case, the location may
  change between the time the request arrives and the time the user authorizes
  sharing; the location to be shared is the one in effect when the user
  authorized sharing, i.e., the one from the most recent location update
  before the button click. Note that rather than include the full
  Android push request API in our model, we simulated it using a basic callback.
  This app has two insecure variants. In the first one, when the user
  presses the ``Share Now'' button, the app shares the location from the time
  of the request. In the second, the app simply
  shares the location immediately in response to all requests.

  % Dropped second and just included first and third, since second
  % kept timing out.  Therefore, "second" in this text refers to the
  % Ex4Evil3 in the repository.

\end{itemize}

% We model the $i$th contact as $con_i$,
% and the spinner channel as \code{s}:

% \begin{displaymath}
%   \begin{array}{c}
%     \code{con_i}? \land \tfuture \big( \code{send}?() \land
%     last(\code{s})=i \big) \rhd L \\
%   \end{array}
% \end{displaymath}

\paragraph*{Scalability.}
We ran our experiments on a 4-core i7 CPU @3.5GHz with 16GB
RAM running Ubuntu 14. For each experiment we report the median of 10
runs.

\begin{figure}[t!]
\centering
\begin{tabular}{cc}
\includegraphics[width=.45\textwidth]{contactpicker} &
\includegraphics[width=.45\textwidth]{bump} \\

\includegraphics[width=.45\textwidth]{locationtoggle} &
\includegraphics[width=.45\textwidth]{whereru}
\end{tabular}
\caption{Runtime vs. number of events.}
\label{fig:performance-graphs}
\end{figure}

In our first set of experiments, we measured how
\toolname{}'s performance varies with input
depth. Figure~\ref{fig:performance-graphs} shows running time 
versus input depth for all programs and variants.
For each app, we ran to the highest input depth that completed in
one hour.

For each app, we see that running time
grows exponentially, as expected. The maximum input depth
before timeout (i.e., where each curve ends) ranges from five to
nine. The differences have to do with the number of possible events at
each input point. For example, WhereRU has seven possible input events, so
it has the largest possible ``fan out,'' and times out with an input
depth of five. In contrast, Bump and Location Toggle have just three
input events, and time out with an input depth of nine. We also note the first
insecure variant of Contact Picker times out after fewer events than
the other variants. Investigating further, this occurs due to
that app's implicit flow (recall the app branches on the value of a
secret input). Implicit flows cause symbolic execution to take
additional branches depending on the (symbolic) secret value.

% Note that the memory usage appears to grow super-exponentially.
% Looking into this, we found that this was from the exploration phase
% of \toolname{}, where each individual path explored takes a larger and
% larger amount of memory as the app executes.

% We found that the main bottleneck contributing to apps timing out in
% our algorithm was memory usage.  Because each input to the app results
% in a set of branches, exploring more events takes exponentially more
% memory.  After exhausting the memory in RAM, the performance of
% \toolname{} degrades, as it has to perform operations on a state space
% that resides partially on disc.

\paragraph*{Minimum Input Depth.}

\begin{figure*}[t]
\centering
\begin{tabular}{ | l | r | r | r | r | r | }
  \hline
%  & \multicolumn{5}{c|}{Min. Necessary Events} \cline{2-6}
%  & \multicolumn{5}{c|}{Max Events in 1hr} \\ \cline{2-11}
  &\#&\multicolumn{3}{c|}{Time (ms)} \\ \cline{3-5} % &\#&Mem&\multicolumn{3}{c|}{Time (s)} \\
%  \cline{4-6} \cline{9-11}
App & Evts & Exploration & Analysis & Total \\ \hline % & Evts & (MB) &  Explor. & Analysis & Total \\
  \hline
  Bump & 3 & 114 &  15 & 142 \\ % & 9 & 5,102 & 75 & 261 & 336 \\
  Bump (insecure 1) & 5 & 2,100 & 1,577 & 3,690 \\ % & 9 & 4,275 & 81 & 215 & 296 \\
  Bump (insecure 2) & 4 & 266 & 70 & 344 \\\hline % & 9 & 5,653 & 79 & 270 & 349 \\
  Location toggle & 2 &  113 & 12 & 128 \\ % & 7 & 197 & 13 & 372 & 385 \\
  Location toggle (insecure 1) & 2 &  143 & 12 & 163 \\ % & 7 & 197 & 13 & 171 & 184 \\
  Location toggle (insecure 2) & 3 & 117 & 12 & 143 \\\hline % & 7 & 195 & 13 & 322 & 335 \\
  Contact picker & 2 &  79 & 2 & 94 \\ % & 7 & 1,606 & 221 & 13 & 234 \\
  Contact picker (insecure 1) & 2 &  325 & 27 & 361 \\ % & 7 & 4,275 & 850 & 57 & 907 \\
  Contact picker (insecure 2) & 2 &  149 & 9 & 170 \\\hline % & 7 & 1,215 & 168 & 13 & 181 \\
  WhereRU & 3 & 849 & 183 & 1,045 \\ % & 5 & 2,495 & 18 & 87 & 105 \\
  WhereRU (insecure 1) & 3 & 860 & 234 & 1,108 \\ % & 5 & 2,495 & 19 & 88 & 107 \\
  WhereRU (insecure 2) & 2 & 257 & 10 & 280 \\ % & 5 & 757 & 22 & 36 & 58 \\  
  \hline
\end{tabular}
\caption{Results at minimum input depth.}
\label{fig:results}
\end{figure*}

Next, for each variant, we manually
calculated a \emph{minimum} input depth that is guaranteed
to find a policy violation, if one exists.
First we determined possible app GUI states.
For example, in Bump (Fig.~\ref{fig:app-bump}), there is a state with \code{idBox} and
\code{phBox} both checked, a state with just \code{idBox} checked,
etc. Then we examined the policy and recognized that certain input
sequences lead to equivalent states modulo the policy.  For example,
input sequences that click \code{idBox} an even number of times and
then click send are all equivalent. Full analysis reveals that an
input depth of three (which allows the checkboxes to be set any
possible way followed by a button click) is
sufficient to reach all possible states for this policy. We performed
similar analysis on other apps and variants.

Fig.~\ref{fig:results} summarizes the results of running with
the minimum input depth for each variant, with the depths listed in
the second column.
We confirmed that, when run with this input depth, \toolname{}
correctly reports the benign app variants as secure and the other app
variants as insecure.
%
The remaining columns of Fig.~\ref{fig:results} report \toolname{}'s
running time (in milliseconds), broken down by the
exploration phase (where SymDroid generates the set of symbolic
traces) and the analysis phase (where SymDroid forms equations about
this set and checks them using Z3).  Looking at the breakdown between
exploration and analysis, we see that the former dominates the running
time, i.e., most of the time is spent simply exploring program
executions.  We see the total running time is typically around a
second or less, while for the first insecure variant of Bump it is
closer to 4 seconds, since it uses the highest input depth.

\paragraph*{Discussion.}

Our results show that while \toolname{} indeed scales exponentially,
to actually find security policy violations we need only run it with a
low input depth, which takes only a small amount of time.

Our experiments used a set of small apps that we
developed. There are two main engineering challenges in applying
\toolname{} to other apps, which we leave to future work. First, our
model of Android (Section~\ref{sec:driver}) only includes part of the
framework. To run on other apps, it will need to be expanded
with more Android APIs. 
%Second, the memory usage of \toolname{}
%can be improved. Recall from Section~\ref{sec:z3-tree} that
%\toolname{} builds a tree of all possible traces and then checks
%IBNI. This requires \toolname{} to hold all paths in memory at
%once. We believe this can be improved by checking IBNI as the tree is
%constructed, and discarding subtrees whenever we can reason that no
%more interference with that subtree is possible. 
Second, we speculate
that larger apps may require longer input depths to go from app launch
to interfering outputs. In these cases, we may be able to start
symbolic execution ``in the middle'' of an app (e.g., as in the
work of Ma et al. \cite{Ma:2011}) to skip uninteresting
prefixes of input events.

\section{Related Work}
\label{sec:related-work}

\toolname is the first system to enforce extensional declassification policies 
in Android apps.  It builds on a rich history of research in usable security,
information flow, and declassification.

One of the key ideas in \toolname is that GUI interactions indicate the 
security desires of users.
Roesner et al.~\cite{Roesner:12} similarly propose \emph{access control gadgets}
(ACGs), which are GUI elements that, when users interact with them,
grant permissions. 
Thus, ACGs and \toolname{} are both an effort to better align 
security with usability~\cite{Yee:04}.
\toolname addresses secure information flow, especially propagation of
information after its release, whereas ACGs address only access control.

\paragraph*{Android-based systems.}

TaintDroid~\cite{Enck:10} is a run-time information-flow tracking system
for Android.  It monitors the usage of sensitive information and detects
when that information is sent over insecure channels.
Like many run-time information-flow control systems,
TaintDroid does not detect \emph{implicit flows}~\cite{King:08}. In contrast,
\toolname does detect implicit flows.
%TaintDroid is efficient enough, however, to run in real time with open-source
%Android apps. 

AppIntent~\cite{Yang:2013} uses symbolic execution to derive the \emph{context},
meaning inputs and GUI interactions, that causes sensitive information to be
released in an Android app. A human analyst examines that context and makes an
expert judgment as to whether the release is really a security violation or not.  
\toolname instead uses human-written LTL formulae to specify whether 
declassifications are permitted. It is unclear from~\cite{Yang:2013} whether AppIntent detects
implicit flows.

Pegasus~\cite{Chen:13} combines static analysis, model checking,
and run-time monitoring to ascertain whether an app uses API
calls and privileges in a way that is consistent with users' expectations.
Those expectations are expressed using LTL formulae, as are \toolname 
declassification policies.  Pegasus synthesizes
a kind of automaton called a \emph{permission event graph} from the
app's bytecode then checks whether that automaton is a model for the formulae.
Unlike \toolname, Pegasus does not address information flow.

Jia et al.~\cite{Jia:13} present a system, inspired by Flume~\cite{Krohn:2007},
for run-time enforcement of information flow policies at the granularity of 
Android components and apps.  This system permits a different form of declassification:
components and apps are trusted to perform declassification according to 
capabilities granted to them in security labels.  In contrast,
\toolname reasons about declassification in terms of user
interactions.
% declassification only under conditions specified by
%LTL formulae.

\paragraph*{Information flow and declassification.}

SIF (Servlet Information Flow)~\cite{Chong:07} is a framework for building
Java servlets with information-flow control.  Information managed by
the servlet is annotated in the source code with security labels, and the compiler 
ensures that information propagates in ways that are consistent with
those labels.  
The SIF compiler is based on Jif \cite{Myers:1999}, an information-flow variant of Java.  
SIF labels include both confidentiality and integrity components;
\toolname{} does not address integrity.
SIF source code can use \emph{selective declassification} to downgrade the security
of information.
In the browser GUI, SIF can render the current security label
associated with text boxes and other GUI widgets.  
SIF is an intensional system (security policies are in-lined with code), whereas
\toolname is extensional (policies are separate from the code).

Chong and Myers~\cite{Chong:04} introduce \emph{declassification policies},
which use \emph{conditions} to 
specify when the policy on some information may be rewritten to a new, perhaps
less restrictive policy.  Their policies use classical propositional logic for conditions.
\toolname can be seen as providing a more expressive language for
conditions by using LTL to express formulae over events.  
Vaughan and Chong~\cite{Vaughan:2011} define expressive declassification policies that
allow functions of secret information to be released after events occur, and
extend the Jif compiler to infer events.  \toolname instead 
ties events to user interactions.

O'Neill et al.~\cite{O'Neill:06}, Clark and Hunt~\cite{Clark:09}, and
Rafnsson et al.~\cite{Rafnsson:12} investigate models, definitions, and enforcement
techniques for secure information flow in interactive programs.
Android apps are real-world examples of interactive programs,
so \toolname is a practical application of this theoretical work.

Sabelfeld and Sands~\cite{Sabelfeld:2009} survey approaches to
secure declassification in a language-based setting.  \toolname
can be seen as addressing their ``what'' and ``when'' axes of
declassification goals:  users of Android apps interact with the GUI
to control when information may be released, and the GUI is responsible
for conveying to the user what information will be released.

\section{Conclusion}
\label{sec:conclusion}

We introduced interaction-based declassification policies, which describe
\emph{what} and \emph{when} information can flow. Policies are defined
using LTL formulae describing event traces, where events include GUI
actions, secret inputs, and network sends. We formalized our policies
using a trace-based model of apps based on security relevant events.
Finally, we described \toolname{}, which uses symbolic
execution to check interaction-based declassification policies on Android, and
showed that \toolname{} correctly enforces policies on four apps,
with one secure and two insecure variants each.

% \section*{Acknowledgments}

% This research was supported in part by NSF grants CNS-1064997 and 1421373, 
% AFOSR grants FA9550-12-1-0334 and FA9550-14-1-0334,
% a partnership between UMIACS and the Laboratory for Telecommunication Sciences,
% and the National Security Agency.

\bibliographystyle{splncs03}
\bibliography{paper}

\end{document}
